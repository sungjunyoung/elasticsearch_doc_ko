> [Getting Started](https://github.com/sungjunyoung/elasticsearch_doc_ko/tree/master/Getting%20Started) > Basic Concepts

### Basic Concept

#### Near Realtime
Elasticsearch 는 리얼타임에 가까운 검색 플랫폼입니다. 이것은 도큐먼트를 인덱싱한 시간부터 검색이 가능해질 때 까지 약간의 레이턴시(1초 정도) 가 있다는 것을 의미합니다.

#### Cluster 클러스터
클러스터는 하나의 노드 혹은 데이터를 묶고있고, 합쳐진 인덱싱과 검색 기능을 제공하는 하나 이상의 노드의 묶음입니다. 클러스터는 기본적으로 ‘elasticsearch’ 라는 고유한 이름으로 식별됩니다. 이 이름은 노드가 클러스터의 이름으로 준비가  되었을 때만 클러스터의 일부가 될 수 있기 때문에 중요합니다.

다른 환경에서 같은 클러스터의 이름을 재사용 하지 않도록 하십시오, 만약 그렇게 하게되면, 노드가 잘못된 클러스터에 포함되어 하던 일이 안될 수 있습니다. 올바른 사용의 한가지 예로, 당신은 ‘logging-dev’, ‘loggin-stage’, ’logging-prod’ 로 개발시, 스테이징시, 프로덕션 시의 클러스터로 이름짓는 것이 가능합니다.

노드가 하나 뿐인 클러스터를 사용하는 것은 타당하며 완벽하게 작동합니다. 또한 고유한 클러스터 이름을 가진 여러 독립 클러스터를 각각 만들 수도 있습니다.

#### Node 노드
노드는 하나의 서버입니다. 노드는 당신의 클러스터의 일부이며, 당신의 데이터를 저장하고, 클러스터의 인덱싱과 검색 기능에 참여합니다. 클러스터와 같이, 하나의 노드는 하나의 고유한 이름을 가집니다. UUID (Universally Unique Identifier 를 Default 로 노드가 시작할 때 이름지어집니다. 당신은 어떤 노드의 이름이고 정의할 수 있습니다. 이 이름은 네트워크의 어느 서버가 Elasticsearch 클러스터의 어떤 노드와 일치하는지 확인하는 등의 관리 목적에서 굉장히 중요합니다.

노드를 클러스터 이름으로 결합하도록 구성 할 수 있습니다. 기본적으로 각 노드는 elasticsearch라는 클러스터에 붙도록 설정됩니다. 즉, 다수의 노드를 당신의 네트워크에서 시작하면, (각각의 노드가 다른 노드를 알 수 있다고 가정하고) 자동으로 elasticsearch라는 단일 클러스터를 형성하고 붙습니다.

단일 클러스터에서, 당신이 원하는 몇개의 노드이든 붙일 수 있습니다. 게다가, 네트워크에 다른 노드가 없다면, 새로운 단일노드를 시작한다는 것은 elastic search 라는 단일 클러스터를 생성하는 것입니다.

#### Index 인덱스
인덱스는 비슷한 특징을 가진 도큐먼트의 집합입니다. 고객 데이터를 위한 인덱스, 제품 카탈로그를 위한 다른 인덱스, 주문 데이터를 위한 또다른 인덱스를 예를 들 수 있습니다. 하나의 인덱스는 또한 이름으로 구분됩니다. (소문자여아 합니다.) 그리고 이 이름은 인덱싱, 검색, 업데이트, 삭제 명령을 수행할 때 구분하기 위해 사용됩니다.

단일 클러스터에서, 몇개든 인덱스를 정의할 수 있습니다.

#### Type 타입
인덱스 내에서 당신은 하나 혹은 그 이상의 타입을 정의할 수 있습니다. 하나의 타입은 인덱스에서의 논리적인 카테고리를 뜻합니다. 논리적인 카테고리의 정의는 전적으로 당신에게 달려 있습니다. 일반적으로, 타입은 동일한 필드의 집합을 가진 도큐먼트를 위해 정의됩니다. 예를들어, 당신이 블로그를 돌리고 있고, 하나의 인덱스에 당신의 모든 데이터를 저장하고 있다고 가정합시다. 당신은 유저 데이터에 대한 타입을 정의하고, 블로그 데이터에 대한 타입을 정의하고, 그리고 댓글 데이터에 대한 타입을 정의합니다.

#### Document 도큐먼트
하나의 다큐먼트는 인덱싱 될 수 있는 단순한 정보의 단위입니다. 예를들어, 당신은 고객에 대한 도큐먼트, 제품에 대한 도큐먼트, 그리고 주문에 대한 도큐먼트를 가질 수 있습니다. 이 도큐먼트는  [JSON](http://json.org/) 으로 표현됩니다.

인덱스/타입 내에서, 당신은 당신이 원하는 몇개의 도큐먼트든 저장할 수 있습니다. 도큐먼트는 물리적으로 인덱스 내에 존재하지만, 인덱스 내에 정의된 타입에 할당되어 있어야 합니다.(?)

#### Shards & Replicas 샤드 & 레플리카
하나의 인덱스는 단일 노드의 하드웨어 제한을 초과한 많은 양의 데이터를 저장할 수 있습니다. 예를들어,  1TB의 디스크 공간을 차지하는 10 억 개의 도큐먼트 인덱스 하나가 단일 노드의 디스크에 맞지 않거나 단일 노드의 검색 요청 만 처리하기에는 너무 느릴 수 있습니다.

이 문제를 해결하기 위해서, Elasticsearch는 당신의 인덱스를 ‘샤드’라고 불리는 여러 조각으로 나눌수 있는 기능을 제공합니다. 인덱스를 만들 때, 당신은 간단히 샤드의 갯수를 정의할 수 있습니다. 샤드는 각각 클러스터의 모든 노드에서 호스트 할수 있는 완전히 기능적이고 독립적인 ‘인덱스’ 입니다.

샤딩은 다음의 두가지 이유에서 중요합니다.

- 샤드는 당신의 컨텐츠 볼륨을 수직적으로 쪼개거나 확장시킬수 있게 합니다.
- 샤드는 여러 노드에서 잠재적으로 분산 (shard)을 통해 작업을 분산 및 병렬 처리 할 수 있으므로 성능과 처리량이 향상됩니다.

Shard가 나눠지는 방법과 문서가 검색 요청으로 다시 집계되는 방법은 Elasticsearch에 의해 완벽하게 관리되며 사용자는 관리할 필요가 없습니다.

fail이 언제든 나타날 수 있는 네트워크 혹은 클라우드 환경에서, 샤드나 노드가 어떤 이유에서 offline 상태가 되거나 사라지는 것을 방지하는 failover 메커니즘을 가지는 것은 굉장히 유용하고 매우 권고하됩니다. Elasticsearch 를 사용하면, 인덱스 샤드의 복사본인 레플리카 샤드를 복제본으로 만들 수 있습니다.

레플리케이션은 다음 두가지 이유에서 중요합니다.

- 레플리케이션은 샤드/노드의 실패 상황에서 높은 가용성을 제공합니다. 이런 이유에서, 복제본 샤드는 복사 된 절대로 원본 / 기본 샤드와 동일한 노드에 할당하지 않도록 합니다.
- 레플리케이션은 당신의 모든 레플리카에서 병렬로 실행되어 검색할수 있게 당신의 검색 볼륨을 스케일 아웃 을 가능케 합니다.

요약하자면, 각각의 인덱스는 다수의 샤드로 쪼개질수 있습니다. 단일 인덱스는 역시나 0 혹은 여러번  ’레플리케이트’ 할 수 있습니다. ‘레플리케이트’ 되면, 각각의 인덱스는 원본 샤드와 레플리카(복제된) 샤드를 가지고 있습니다. 인덱스가 생성될 때마다, 인덱스별  샤드와 레플리카의 갯수를 정의할 수 있습니다. 인덱스가 만들어지고 나면, 당신은 당신이 원할 때 동적으로 레플리카의 갯수를 변경할 수 있습니다. 하지만, 샤드의 갯수는 변경이 불가능합니다.

기본적으로, Elasticsearch 의 각각의 인덱스에는 다섯개의 샤드와 한개의 레플리카가 할당됩니다. 이것은 당신의 클러스터에 두개의 노드를 가지고 있다면, 당신의 인덱스는 5개의 원본 샤드와 5개의 레플리카 샤드를 가지고 있는 것입니다. 즉, 인덱스당 10개의 샤드를 가집니다.  

> 각각의 Elasticsearch 샤드는 Lucene 인덱스 입니다. 당신이 단일 Lucene 인덱스에서 가질수 있는 최대 제한 도큐먼트 수가 존재합니다. [LUCENE-5843](https://issues.apache.org/jira/browse/LUCENE-5843)과 같이, 제한 수는 2,147,483,519 (= Integer.MAX_VALUE - 128) 개의 도큐먼트 입니다. 당신은 [_cat/shards](https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-shards.html) API 를 사용하여  샤드의 수를 모니터할 수 있습니다.
